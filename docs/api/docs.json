[{"name":"Tidy","comment":" A collection of utilities for representing tabular data and reshaping them.\n\n\n## Table Representation\n\n@docs Table\n@docs fromCSV\n@docs tableSummary\n\n\n## Table Tidying\n\n[Tidy data](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf)\nis a convention for organising tabular data such that columns represent _variables_\nand rows represent _observations_. This greatly simplifies data interchange and\nmany data analytical functions.\n\nCommon problems with data that are not in tidy format (\"messy\" data) include:\n\n  - Column headers are values not variable names\n  - Multiple variables are stored in the same column\n  - Variables arranged in rows as well as columns\n  - Multiple types of observational unit are stored in the same table\n  - The same observational unit is stored in multiple tables.\n\nMessy data can be tidied with a small number of simple operations.\n\n@docs melt\n\n\n## Table Joining\n\nJoin two tables using a common key. While not specific to tidy data, joining tidy\ntables is often more meaningful than joining messy ones. The examples below illustrate\njoining two input tables as follows with shared key values k2 and k4:\n\n```markdown\ntable1:\n\n| Key | colLabelA | colLabelB |\n| --- | --------- | --------- |\n| k1  | a1        | b1        |\n| k2  | a2        | b2        |\n| k3  | a3        | b3        |\n| k4  | a4        | b4        |\n\ntable2:\n\n| Key | colLabelC | colLabelD |\n| --- | --------- | --------- |\n| k2  | c2        | d2        |\n| k4  | c4        | d4        |\n| k6  | c6        | d6        |\n| k8  | c8        | d8        |\n```\n\n@docs leftJoin\n@docs rightJoin\n@docs innerJoin\n@docs outerJoin\n\n\n## Table Filtering\n\n@docs filterRows\n\n\n## Column coversion\n\n@docs toColumn\n@docs numColumn\n@docs strColumn\n@docs boolColumn\n\n","unions":[],"aliases":[{"name":"Table","comment":" The main unit of data organsiation is the `Table`, which is a collection of\ndata columns each referenced by a column name. All table values are\n[Strings](https://package.elm-lang.org/packages/elm/core/latest/String) but can be\nconverted into other types when necessary.\n","args":[],"type":"Dict.Dict String.String (List.List String.String)"}],"values":[{"name":"boolColumn","comment":" Extract Boolean values of a given column from a table. Any conversions that\nfail are not included in the resulting list of values. Assumes that `True` values\ncan be represented by the case-insenstive strings `true`, `yes` and `1`, and that\n`False` values can be represented by `false`, `no` and `0`. All other values will\nbe ignored and not provided in the resulting list.\n\n      myTable |> toBool \"isMarried\"\n\n","type":"String.String -> Tidy.Table -> List.List Basics.Bool"},{"name":"filterRows","comment":" Keep rows in the table where the values in the given column satisfy the given\ntest. The test should be a function that takes a string representing the cell value\nand returns either true or false depending on whether the row containing that value\nin the column should be retained.\n\n    isWarm : String -> Bool\n    isWarm s =\n        case String.toFloat s of\n            Just x ->\n                x >= 10\n\n            Nothing ->\n                False\n\n    warmCities =\n        myTable |> filterRows \"temperature\" isWarm\n\n","type":"String.String -> (String.String -> Basics.Bool) -> Tidy.Table -> Tidy.Table"},{"name":"fromCSV","comment":" Given a multi-line comma-separated string representing a table in the form:\n\n    \"\"\"colLabelA,colLabelB,colLabelC,etc.\n       a1,b1,c1, etc.\n       a2,b2,c2, etc.\n       a3,b3,c3, etc.\n       etc.\"\"\"\n\nTransform it into a dictonary of columns referenced by the column label (a `Table`):\n\n```markdown\ncolLabelA → [a1, a2, a3, ...]\ncolLabelB → [b1, b2, b3, ...]\ncolLabelC → [c1, c2, c3, ...]\netc.\n```\n\n","type":"String.String -> Tidy.Table"},{"name":"innerJoin","comment":" An 'inner join' will contain only key-matched rows that are present in both tables.\n\n    innerJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k2  | a2        | b2        | c2        | d2        |\n| k4  | a4        | b4        | c4        | d4        |\n```\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"leftJoin","comment":" A _left join_ preserves all the values in the first table and adds any key-matched\nvalues from columns in the second table to it. Where both tables share common column\nnames, only those in the left (first) table are stored in the output.\n\n    leftJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k1  | a1        | b1        |           |           |\n| k2  | a2        | b2        | c2        | d2        |\n| k3  | a3        | b3        |           |           |\n| k4  | a4        | b4        | c4        | d4        |\n```\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"melt","comment":" Combine several columns that represent the same variable into two columns, one\nreferencing the original column, the other the values of the variable. For example\nthe following messy table\n\n```markdown\n| location  | temperature2017 | temperature2018 |\n| --------- | --------------- | --------------- |\n| Bristol   | 12              | 14              |\n| Sheffield | 11              | 13              |\n| Glasgow   |  8              |  9              |\n```\n\ncan be melted to create a tidy table:\n\n```markdown\n| location  | year | temperature |\n| --------- | ---- | ----------- |\n| Bristol   | 2017 | 12          |\n| Bristol   | 2018 | 14          |\n| Sheffield | 2017 | 11          |\n| Sheffield | 2018 | 13          |\n| Glasgow   | 2017 |  8          |\n| Glasgow   | 2017 |  9          |\n```\n\nThe first two parameters represent the names to be given to the column reference\n(`year` in the example above) and variable column (`temperature` in the example above)\nto be generated. The third is a list of the (columnName,columnReference)\nto be melted (e.g. `[ (\"temperature2017\", \"2017\"), (\"temperature2018\", \"2017\") ]`\nabove) and the final, the table to convert. For example\n\n    \"\"\"location,temperature2017,temperature2017\n    Bristol,12,14\n    Sheffield,11,13\n    Glasgow, 8,9\"\"\"\n        |> fromCSV\n        |> melt \"year\"\n            \"temperature\"\n            [ ( \"temperature2017\", \"2017\" )\n            , ( \"temperature2018\", \"2018\" )\n            ]\n\n","type":"String.String -> String.String -> List.List ( String.String, String.String ) -> Tidy.Table -> Tidy.Table"},{"name":"numColumn","comment":" Extract the numeric values of a given column from a table. Any conversions that\nfail are not included in the resulting list of values. This is a convenience function\nequivalent calling [toColumn](#toColumn) providing the conversion function\n[String.toFloat](https://package.elm-lang.org/packages/elm/core/latest/String#toFloat)\n\n    myTable |> numColumn \"year\"\n\n","type":"String.String -> Tidy.Table -> List.List Basics.Float"},{"name":"outerJoin","comment":" An _outer join_ contains all rows of both joined tables.\n\n    outerJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k1  | a1        | b1        |           |           |\n| k2  | a2        | b2        | c2        | d2        |\n| k3  | a3        | b3        |           |           |\n| k4  | a4        | b4        | c4        | d4        |\n| k6  |           |           | c6        | d6        |\n| k8  |           |           | c8        | d8        |\n```\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"rightJoin","comment":" A _right join_ preserves all the values in the second table and adds any key-matched\nvalues from columns in the first table to it. Where both tables share common column\nnames, only those in the right (second) table are stored in the output.\n\n    rightJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k2  | a2        | b2        | c2        | d2        |\n| k4  | a4        | b4        | c4        | d4        |\n| k6  |           |           | c6        | d6        |\n| k8  |           |           | c8        | d8        |\n```\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"strColumn","comment":" Extract the string values of a given column from a table.\n\n    myTable |> strColumn \"location\"\n\n","type":"String.String -> Tidy.Table -> List.List String.String"},{"name":"tableSummary","comment":" Provide a textual description of a table, configurable to show a given number\nof table rows. If the number of rows to show is negative, all rows are output.\nThis is designed primarily to generate markdown output, but should be interpretable\nas raw text.\n","type":"Basics.Int -> Tidy.Table -> List.List String.String"},{"name":"toColumn","comment":" Extract the values of a given column from a table. The type of values in the\ncolumn is determined by the given string conversion function. Any conversions that\nfail are not included in the resulting list of values.\n\n    imputeMissing : String -> Maybe Int\n    imputeMissing val =\n        case String.toInt val of\n            Just n ->\n                Just n\n\n            Nothing ->\n                Just 0\n\n    myTable |> toColumn \"count\" imputeMissing\n\n","type":"String.String -> (String.String -> Maybe.Maybe a) -> Tidy.Table -> List.List a"}],"binops":[]}]