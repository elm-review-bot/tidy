[{"name":"Tidy","comment":" A collection of utilities for representing tabular data and reshaping them.\n\n@docs Table\n\n\n# Create\n\n@docs fromCSV\n@docs fromGridText\n@docs fromGridLists\n@docs empty\n\n\n# Edit\n\n@docs insertRow\n@docs filterRows\n\n@docs renameColumn\n@docs insertColumn\n@docs removeColumn\n@docs filterColumns\n\n\n# Tidy\n\n[Tidy data](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf)\nis a convention for organising tabular data such that columns represent _variables_\nand rows represent _observations_. This greatly simplifies data interchange and\nmany data analytical functions.\n\nCommon problems with data that are not in tidy format (\"messy\" data) include:\n\n  - Column headers are values not variable names\n  - Multiple variables are stored in the same column\n  - Variables arranged in rows as well as columns\n  - Multiple types of observational unit are stored in the same table\n  - The same observational unit is stored in multiple tables.\n\nMessy data can be tidied with a small number of simple operations.\n\n@docs melt\n@docs transposeTable\n\n\n# Join\n\nJoin two tables using a common key. While not specific to tidy data, joining tidy\ntables is often more meaningful than joining messy ones. The examples below illustrate\njoining two input tables as follows with shared key values `k2` and `k4`:\n\n```markdown\ntable1:\n\n| Key1 | colA | colB |\n| ---- | ---- | ---- |\n| k1   | a1   | b1   |\n| k2   | a2   | b2   |\n| k3   | a3   | b3   |\n| k4   | a4   | b4   |\n\ntable2:\n\n| Key2 | colC | colD |\n| ---- | ---- | ---- |\n| k2   | c2   | d2   |\n| k4   | c4   | d4   |\n| k6   | c6   | d6   |\n| k8   | c8   | d8   |\n```\n\n@docs leftJoin\n@docs rightJoin\n@docs innerJoin\n@docs outerJoin\n\n\n# Output\n\n@docs tableSummary\n\n\n## Column output\n\n@docs numColumn\n@docs strColumn\n@docs boolColumn\n@docs toColumn\n\n","unions":[{"name":"Table","comment":" A table of data arranged in rows and columns. Each column in a table has a\nunique name by which it may be referenced. Table cell values are represented as\nStrings, but can be converted to other types via column output functions\n(e.g. [numColumn](#numColumn)).\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"boolColumn","comment":" Extract Boolean values of a given column from a table. Assumes that `True`\nvalues can be represented by the case-insenstive strings `true`, `yes` and `1`\nwhile all other values are assumed to be false.\n\n      myTable |> toBool \"isMarried\"\n\n","type":"String.String -> Tidy.Table -> List.List Basics.Bool"},{"name":"empty","comment":" Create an empty table. Useful if table items are to be added programatically\nwith `insertRow` and `insertColumn`.\n","type":"Tidy.Table"},{"name":"filterColumns","comment":" Keep columns in the table whose names satisfy the given test. The test should\nbe a function that takes a column heading and returns either `True` or `False`\ndepending on whether the column should be retained.\n\n    myTable |> filterColumns ((==) \"temperature2017\")\n\n","type":"(String.String -> Basics.Bool) -> Tidy.Table -> Tidy.Table"},{"name":"filterRows","comment":" Keep rows in the table where the values in the given column satisfy the given\ntest. The test should be a function that takes a cell value and returns either\n`True` or `False` depending on whether the row containing that value in the column\nshould be retained.\n\n    isWarm : String -> Bool\n    isWarm s =\n        case String.toFloat s of\n            Just x ->\n                x >= 10\n\n            Nothing ->\n                False\n\n    warmCities =\n        myTable |> filterRows \"temperature\" isWarm\n\n","type":"String.String -> (String.String -> Basics.Bool) -> Tidy.Table -> Tidy.Table"},{"name":"fromCSV","comment":" Create a table from a multi-line comma-separated string in the form:\n\n    \"\"\"colLabelA,colLabelB,colLabelC,etc.\n       a1,b1,c1, etc.\n       a2,b2,c2, etc.\n       a3,b3,c3, etc.\n       etc.\"\"\"\n\n","type":"String.String -> Tidy.Table"},{"name":"fromGridLists","comment":" Transform list of input string lists in the form:\n\n    [ [z00, z01, z02, z03, ...]\n    , [z10, z11, z12, z13, ...]\n    , [z20, z21, z22, c23, ...]\n    , [z30, z31, z32, c33, ...]\n    , [...]\n    ]\n\ninto a tidy table in the form:\n\n```markdown\n| row | col |   z |\n| --- | --- | --- |\n|   0 |   0 | z00 |\n|   0 |   1 | z01 |\n|   0 |   2 | z02 |\n|   0 |   3 | z03 |\n|   1 |   0 | z10 |\n|   1 |   1 | z11 |\n|   : |   : |   : |\n```\n\nNote the common convention that in grids, the origin (row 0) is at the top-left\nwhereas in Cartesian coordinate systems the origin (y = 0) is at the bottom-left.\nYou may therefore wish to perform an additional reversing of the order of row\nlists in the input if you are mapping onto a Cartesian coordinate system.\n\n","type":"List.List (List.List String.String) -> Tidy.Table"},{"name":"fromGridText","comment":" Transform multi-line string input values in the form:\n\n    \"\"\"\n       z00,z01,z02,z03, etc.\n       z10,z11,z12,z13, etc.\n       z20,z21,z22,c23, etc.\n       z30,z31,z32,c33, etc.\n       etc.\"\"\"\n\ninto a tidy table in the form:\n\n```markdown\n| row | col |   z |\n| --- | --- | --- |\n|   0 |   0 | z00 |\n|   0 |   1 | z01 |\n|   0 |   2 | z02 |\n|   0 |   3 | z03 |\n|   1 |   0 | z10 |\n|   1 |   1 | z11 |\n|   : |   : |   : |\n```\n\nNote the common convention that in grids, the origin (row 0) is at the top-left\nwhereas in Cartesian coordinate systems the origin (y = 0) is at the bottom-left.\nYou may therefore wish to perform an additional transformation on the ordering of\nrow values in the input string if you are mapping onto a Cartesian coordinate system.\n\n","type":"String.String -> Tidy.Table"},{"name":"innerJoin","comment":" An 'inner join' will contain only key-matched rows that are present in both tables.\nThe first parameter is the name to give the new key-matched column, replacing the\nseparate key names in the two tables. Where both tables share a common column name,\nonly one is stored in the output.\n\n    innerJoin \"Key\" ( table1, \"Key1\" ) ( table2, \"Key2\" )\n\nwould generate\n\n```markdown\n| Key | colA | colB | colC | colD |\n| --- | ---- | ---- | ---- | ---- |\n| k2  | a2   | b2   | c2   | d2   |\n| k4  | a4   | b4   | c4   | d4   |\n```\n\nIf one or both of the key columns are not found, this produces an empty table.\n\n","type":"String.String -> ( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"insertColumn","comment":" Add a column of data to a table. The first parameter is the name to give the\ncolumn. The second is a list of column values. If the table already has a column\nwith this name, it will get replaced with the given data. To ensure table rows are\nalways aligned, if the table is not empty, the column values are padded / truncated\nto match the number of rows in the table.\n","type":"String.String -> List.List String.String -> Tidy.Table -> Tidy.Table"},{"name":"insertRow","comment":" Add a row of values to a table. The new values are represented by a list of\n`(columnName,columnValue)` tuples. The columnNames should correspond to the names\nof the columns in the table to which each `columnValue` is added. Names not in the\ntable to append are ignored and any unspecified columns have an empty string value\ninserted.\n","type":"List.List ( String.String, String.String ) -> Tidy.Table -> Tidy.Table"},{"name":"leftJoin","comment":" A _left join_ preserves all the values in the first table and adds any key-matched\nvalues from columns in the second table to it. Where both tables share common column\nnames, including key columns, only those in the left (first) table are stored in the output.\n\n    leftJoin ( table1, \"Key1\" ) ( table2, \"Key2\" )\n\nwould generate\n\n```markdown\n| Key1 | colA | colB | Key2 | colC | colD |\n| ---- | ---- | ---- | --- | ---- | ---- |\n| k1   | a1   | b1   |     |      |      |\n| k2   | a2   | b2   | k2  | c2   | d2   |\n| k3   | a3   | b3   |     |      |      |\n| k4   | a4   | b4   | k4  | c4   | d4   |\n```\n\nIf one or both of the key columns are not found, the left table is returned.\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"melt","comment":" Combine several columns that represent the same variable into two columns, one\nreferencing the original column, the other the values of the variable. For example\nthe following messy table\n\n```markdown\n| location  | temperature2017 | temperature2018 |\n| --------- | --------------- | --------------- |\n| Bristol   | 12              | 14              |\n| Sheffield | 11              | 13              |\n| Glasgow   |  8              |  9              |\n```\n\ncan be melted to create a tidy table:\n\n```markdown\n| location  | year | temperature |\n| --------- | ---- | ----------- |\n| Bristol   | 2017 | 12          |\n| Bristol   | 2018 | 14          |\n| Sheffield | 2017 | 11          |\n| Sheffield | 2018 | 13          |\n| Glasgow   | 2017 |  8          |\n| Glasgow   | 2017 |  9          |\n```\n\nThe first two parameters represent the heading names to be given to the column\nreference (`year` in the example above) and variable column (`temperature` in the\nexample above) to be generated. The third is a list of the (columnName,columnReference)\nto be melted (e.g. `[ (\"temperature2017\", \"2017\"), (\"temperature2018\", \"2017\") ]`\nabove) and the final, the table to convert. For example\n\n    \"\"\"location,temperature2017,temperature2018\n    Bristol,12,14\n    Sheffield,11,13\n    Glasgow, 8,9\"\"\"\n        |> fromCSV\n        |> melt \"year\"\n            \"temperature\"\n            [ ( \"temperature2017\", \"2017\" )\n            , ( \"temperature2018\", \"2018\" )\n            ]\n\n","type":"String.String -> String.String -> List.List ( String.String, String.String ) -> Tidy.Table -> Tidy.Table"},{"name":"numColumn","comment":" Extract the numeric values of a given column from a table. Any conversions\nthat fail, including missing values in the table are converted into zeros. If\nyou wish to handle missing data / failed conversions in a different way, use\n[toColumn](#toColumn) instead, providing a custom converter function.\n\n    myTable |> numColumn \"year\"\n\n","type":"String.String -> Tidy.Table -> List.List Basics.Float"},{"name":"outerJoin","comment":" An _outer join_ contains all rows of both joined tables. The first parameter\nis the name to give the new key-matched column, replacing the separate key names\nin the two tables.\n\n    outerJoin \"Key\" ( table1, \"Key1\" ) ( table2, \"Key2\" )\n\nwould generate\n\n```markdown\n| Key | colA | colB | colC | colD |\n| --- | ---- | ---- | ---- | ---- |\n| k1  | a1   | b1   |      |      |\n| k2  | a2   | b2   | c2   | d2   |\n| k3  | a3   | b3   |      |      |\n| k4  | a4   | b4   | c4   | d4   |\n| k6  |      |      | c6   | d6   |\n| k8  |      |      | c8   | d8   |\n```\n\nIf one or both of the key columns are not found, this produces an empty table.\n\n","type":"String.String -> ( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"removeColumn","comment":" Remove a column with the given name from a table. If the column is not present\nin the table, the original table is returned.\n","type":"String.String -> Tidy.Table -> Tidy.Table"},{"name":"renameColumn","comment":" Rename the given column (first parameter) with a new name (second parameter).\nIf the new column name matches an exsiting one, the existing one will be replaced\nby the renamed column.\n","type":"String.String -> String.String -> Tidy.Table -> Tidy.Table"},{"name":"rightJoin","comment":" A _right join_ preserves all the values in the second table and adds any\nkey-matched values from columns in the first table to it. Where both tables share\ncommon column names, including key columns, only those in the right (second) table\nare stored in the output.\n\n    rightJoin ( table1, \"Key1\" ) ( table2, \"Key2\" )\n\nwould generate\n\n```markdown\n| Key2 | colC | colD | Key1 | colA | colB |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| k2   | c2   | d2   | k2   | a2   | b2   |\n| k4   | c4   | d4   | k4   | a4   | b4   |\n| k6   | c6   | d6   |      |      |      |\n| k8   | c8   | d8   |      |      |      |\n```\n\nIf one or both of the key columns are not found, the right table is returned.\n\n","type":"( Tidy.Table, String.String ) -> ( Tidy.Table, String.String ) -> Tidy.Table"},{"name":"strColumn","comment":" Extract the string values of a given column from a table. Missing values in\nthe table are represented as empty strings. If you wish to handle missing values\nin a different way, use [toColumn](#toColumn) instead, providing a custom converter\nfunction.\n\n    myTable |> strColumn \"cityName\"\n\n","type":"String.String -> Tidy.Table -> List.List String.String"},{"name":"tableSummary","comment":" Provide a textual description of a table, configurable to show a given number\nof table rows. If the number of rows to show is negative, all rows are output.\nThis is designed primarily to generate markdown output, but should be interpretable\nas raw text.\n","type":"Basics.Int -> Tidy.Table -> List.List String.String"},{"name":"toColumn","comment":" Extract the values of the column with the given name (first parameter) from a\ntable. The type of values in the column is determined by the given cell conversion\nfunction. The converter function should handle cases of missing data in the table\nas well as failed conversions (e.g. attempts to convert text into a number).\n\n    imputeMissing : String -> Int\n    imputeMissing =\n        String.toFloat >> Maybe.withDefault 0\n\n    myTable |> toColumn \"count\" imputeMissing\n\n","type":"String.String -> (String.String -> a) -> Tidy.Table -> List.List a"},{"name":"transposeTable","comment":" Transpose the rows and columns of a table. To do this you need to provide the\nname of column that will generate the column headings in the transposed table\n(first parameter) and the name you wish to give the new row names (second parameter).\n\nFor example,\n\n    transposeTable \"location\" \"temperature\" table\n\nwhere `table` stores:\n\n```markdown\n| location  | temperature2017 | temperature2018 |\n| --------- | --------------- | --------------- |\n| Bristol   | 12              | 14              |\n| Sheffield | 11              | 13              |\n| Glasgow   |  8              |  9              |\n```\n\ncreates the following table:\n\n```markdown\n| temperature     | Bristol | Sheffield | Glasgow |\n| --------------- | ------- | --------- | ------- |\n| temperature2017 | 12      | 11        | 8       |\n| temperature2018 | 14      | 13        | 9       |\n```\n\nIf the column to contain new headings cannot be found, an empty table is generated.\nIf there are repeated names in the new headings column, earlier rows are replaced\nwith later repeated ones.\n\n","type":"String.String -> String.String -> Tidy.Table -> Tidy.Table"}],"binops":[]}]