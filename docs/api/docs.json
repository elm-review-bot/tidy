[{"name":"Tidy","comment":" A collection of utilities for representing tabular data and reshaping them.\n\n\n## Table Representation\n\n@docs Table\n@docs Heading\n@docs Cell\n@docs fromCSV\n@docs fromGrid\n@docs tableSummary\n\n\n## Table Tidying\n\n[Tidy data](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf)\nis a convention for organising tabular data such that columns represent _variables_\nand rows represent _observations_. This greatly simplifies data interchange and\nmany data analytical functions.\n\nCommon problems with data that are not in tidy format (\"messy\" data) include:\n\n  - Column headers are values not variable names\n  - Multiple variables are stored in the same column\n  - Variables arranged in rows as well as columns\n  - Multiple types of observational unit are stored in the same table\n  - The same observational unit is stored in multiple tables.\n\nMessy data can be tidied with a small number of simple operations.\n\n@docs melt\n\n\n## Table Joining\n\nJoin two tables using a common key. While not specific to tidy data, joining tidy\ntables is often more meaningful than joining messy ones. The examples below illustrate\njoining two input tables as follows with shared key values k2 and k4:\n\n```markdown\ntable1:\n\n| Key | colLabelA | colLabelB |\n| --- | --------- | --------- |\n| k1  | a1        | b1        |\n| k2  | a2        | b2        |\n| k3  | a3        | b3        |\n| k4  | a4        | b4        |\n\ntable2:\n\n| Key | colLabelC | colLabelD |\n| --- | --------- | --------- |\n| k2  | c2        | d2        |\n| k4  | c4        | d4        |\n| k6  | c6        | d6        |\n| k8  | c8        | d8        |\n```\n\n@docs leftJoin\n@docs rightJoin\n@docs innerJoin\n@docs outerJoin\n\n\n## Table Filtering\n\n@docs filterRows\n@docs filterColumns\n\n\n## Column conversion\n\n@docs numColumn\n@docs strColumn\n@docs boolColumn\n@docs toColumn\n\n","unions":[{"name":"Table","comment":" A table of data arranged in rows and columns.\n","args":[],"cases":[]}],"aliases":[{"name":"Cell","comment":" Type of data stored in the cells that make up a table.\n","args":[],"type":"String.String"},{"name":"Heading","comment":" Type used to represent table column headings.\n","args":[],"type":"String.String"}],"values":[{"name":"boolColumn","comment":" Extract Boolean values of a given column from a table. Assumes that `True`\nvalues can be represented by the case-insenstive strings `true`, `yes` and `1`\nwhile all other values are assumed to be false.\n\n      myTable |> toBool \"isMarried\"\n\n","type":"Tidy.Heading -> Tidy.Table -> List.List Basics.Bool"},{"name":"filterColumns","comment":" Keep columns in the table whose names satisfy the given test. The test should\nbe a function that takes a column heading and returns either `True` or `False`\ndepending on whether the column should be retained.\n\n    myTable |> filterColumns ((==) \"temperature2017\")\n\n","type":"(Tidy.Heading -> Basics.Bool) -> Tidy.Table -> Tidy.Table"},{"name":"filterRows","comment":" Keep rows in the table where the values in the given column satisfy the given\ntest. The test should be a function that takes a cell value and returns either\n`True` or `False` depending on whether the row containing that value in the column\nshould be retained.\n\n    isWarm : Cell -> Bool\n    isWarm s =\n        case String.toFloat s of\n            Just x ->\n                x >= 10\n\n            Nothing ->\n                False\n\n    warmCities =\n        myTable |> filterRows \"temperature\" isWarm\n\n","type":"Tidy.Heading -> (Tidy.Cell -> Basics.Bool) -> Tidy.Table -> Tidy.Table"},{"name":"fromCSV","comment":" Create a table from a multi-line comma-separated string in the form:\n\n    \"\"\"colLabelA,colLabelB,colLabelC,etc.\n       a1,b1,c1, etc.\n       a2,b2,c2, etc.\n       a3,b3,c3, etc.\n       etc.\"\"\"\n\n","type":"String.String -> Tidy.Table"},{"name":"fromGrid","comment":" Transform row-prime grid of input values in the form:\n\n    \"\"\"\n       z00,z01,z02,z03, etc.\n       z10,z11,z12,z13, etc.\n       z20,z21,z22,c23, etc.\n       z30,z31,z32,c33, etc.\n       etc.\"\"\"\n\ninto a tidy table in the form:\n\n```markdown\n| row | col |   z |\n| --- | --- | --- |\n|   0 |   0 | z00 |\n|   0 |   1 | z00 |\n|   0 |   2 | z00 |\n|   0 |   3 | z00 |\n|   1 |   0 | z10 |\n|   1 |   1 | z11 |\n|   : |   : |   : |\n```\n\n","type":"String.String -> Tidy.Table"},{"name":"innerJoin","comment":" An 'inner join' will contain only key-matched rows that are present in both tables.\n\n    innerJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k2  | a2        | b2        | c2        | d2        |\n| k4  | a4        | b4        | c4        | d4        |\n```\n\n","type":"( Tidy.Table, Tidy.Heading ) -> ( Tidy.Table, Tidy.Heading ) -> Tidy.Table"},{"name":"leftJoin","comment":" A _left join_ preserves all the values in the first table and adds any key-matched\nvalues from columns in the second table to it. Where both tables share common column\nnames, only those in the left (first) table are stored in the output.\n\n    leftJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k1  | a1        | b1        |           |           |\n| k2  | a2        | b2        | c2        | d2        |\n| k3  | a3        | b3        |           |           |\n| k4  | a4        | b4        | c4        | d4        |\n```\n\n","type":"( Tidy.Table, Tidy.Heading ) -> ( Tidy.Table, Tidy.Heading ) -> Tidy.Table"},{"name":"melt","comment":" Combine several columns that represent the same variable into two columns, one\nreferencing the original column, the other the values of the variable. For example\nthe following messy table\n\n```markdown\n| location  | temperature2017 | temperature2018 |\n| --------- | --------------- | --------------- |\n| Bristol   | 12              | 14              |\n| Sheffield | 11              | 13              |\n| Glasgow   |  8              |  9              |\n```\n\ncan be melted to create a tidy table:\n\n```markdown\n| location  | year | temperature |\n| --------- | ---- | ----------- |\n| Bristol   | 2017 | 12          |\n| Bristol   | 2018 | 14          |\n| Sheffield | 2017 | 11          |\n| Sheffield | 2018 | 13          |\n| Glasgow   | 2017 |  8          |\n| Glasgow   | 2017 |  9          |\n```\n\nThe first two parameters represent the heading names to be given to the column\nreference (`year` in the example above) and variable column (`temperature` in the\nexample above) to be generated. The third is a list of the (columnName,columnReference)\nto be melted (e.g. `[ (\"temperature2017\", \"2017\"), (\"temperature2018\", \"2017\") ]`\nabove) and the final, the table to convert. For example\n\n    \"\"\"location,temperature2017,temperature2017\n    Bristol,12,14\n    Sheffield,11,13\n    Glasgow, 8,9\"\"\"\n        |> fromCSV\n        |> melt \"year\"\n            \"temperature\"\n            [ ( \"temperature2017\", \"2017\" )\n            , ( \"temperature2018\", \"2018\" )\n            ]\n\n","type":"Tidy.Heading -> Tidy.Heading -> List.List ( Tidy.Heading, Tidy.Cell ) -> Tidy.Table -> Tidy.Table"},{"name":"numColumn","comment":" Extract the numeric values of a given column from a table. Any conversions that\nfail, including missing values in the table are converted into zeros. If you wish\nto handle missing data / failed conversions in a different way, use\n[toColumn](#toColumn) instead, providing a custom converter function.\n\n    myTable |> numColumn \"year\"\n\n","type":"Tidy.Heading -> Tidy.Table -> List.List Basics.Float"},{"name":"outerJoin","comment":" An _outer join_ contains all rows of both joined tables.\n\n    outerJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k1  | a1        | b1        |           |           |\n| k2  | a2        | b2        | c2        | d2        |\n| k3  | a3        | b3        |           |           |\n| k4  | a4        | b4        | c4        | d4        |\n| k6  |           |           | c6        | d6        |\n| k8  |           |           | c8        | d8        |\n```\n\n","type":"( Tidy.Table, Tidy.Heading ) -> ( Tidy.Table, Tidy.Heading ) -> Tidy.Table"},{"name":"rightJoin","comment":" A _right join_ preserves all the values in the second table and adds any key-matched\nvalues from columns in the first table to it. Where both tables share common column\nnames, only those in the right (second) table are stored in the output.\n\n    rightJoin ( table1, \"Key\" ) ( table2, \"Key\" )\n\nwould generate\n\n```markdown\n| Key | colLabelA | colLabelB | colLabelC | colLabelD |\n| --- | --------- | --------- | --------- | --------- |\n| k2  | a2        | b2        | c2        | d2        |\n| k4  | a4        | b4        | c4        | d4        |\n| k6  |           |           | c6        | d6        |\n| k8  |           |           | c8        | d8        |\n```\n\n","type":"( Tidy.Table, Tidy.Heading ) -> ( Tidy.Table, Tidy.Heading ) -> Tidy.Table"},{"name":"strColumn","comment":" Extract the string values of a given column from a table. Missing values in\nthe table are represented as empty strings. If you wish to handle missing values\nin a different way, use [toColumn](#toColumn) instead, providing a custom converter\nfunction.\n\n    myTable |> strColumn \"cityName\"\n\n","type":"Tidy.Heading -> Tidy.Table -> List.List String.String"},{"name":"tableSummary","comment":" Provide a textual description of a table, configurable to show a given number\nof table rows. If the number of rows to show is negative, all rows are output.\nThis is designed primarily to generate markdown output, but should be interpretable\nas raw text.\n","type":"Basics.Int -> Tidy.Table -> List.List String.String"},{"name":"toColumn","comment":" Extract the values of a given column from a table. The type of values in the\ncolumn is determined by the given cell conversion function. The converter function\nshould handle cases of missing data in the table as well as failed conversions\n(e.g. attempts to convert text into a number).\n\n    imputeMissing : Cell -> Int\n    imputeMissing =\n        String.toFloat >> Maybe.withDefault 0\n\n    myTable |> toColumn \"count\" imputeMissing\n\n","type":"Tidy.Heading -> (Tidy.Cell -> a) -> Tidy.Table -> List.List a"}],"binops":[]}]